\subsection*{3.4.1}
\begin{verbatim}
// Der Arrayindex beginnt bei 1.
merge(A,l,q,r)
    int curA = l;
    int curB = q+1;
    Array C = new Array;
    int curC = 1;

    while ((q - curA) > -1 && (r - curB) > -1)
        if (A[curA] <= A[curB])
            C[curC] = A[curA]
            ++curA
        else
            C[curC] = A[curB]
            ++curB
        ++curC

    if ((q - curA) == -1)
        while((r - curB) > -1)
            C[curC] = A[curB]
            ++curB
            ++curC
    else
        while((q - curA) > -1)
            C[curC] = A[curA]
            ++curA
            ++curC

    return C;
\end{verbatim}

\subsection*{3.4.2}
Wir zerlegen das Array in Teilarrays, um anschließend eine Konfliktanalyse mit den Teilarrays durchzuführen.\\
Nach Abschluss werden die beiden Arrays zusammengeführt, wobei die Konflikte der beiden Arrays aufeinander geprüft werden.\\
Folgender Pseudocode soll den Algorithmus darstellen:
\begin{verbatim}
checkForConflicts(A,l,r)
    if (l < r) then
        q = (l+r)/2
        checkForConflicts(A,l,q)
        checkForConflicts(A,q+1,r)
        countForConflicts(A,l,q,r)
    end if

countConflicts(A,l,q,r)
    curA = l
    curB = q+1
    count = 0
    while curA <= q
        if (A[curA] > A[curB]) then
            count++
        end if
        curB++
        if (curB > r) then
            curB = q+1
            curA++
        end if
return count
\end{verbatim}